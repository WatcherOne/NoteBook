<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.6.2 (469632)"/><meta name="altitude" content="0"/><meta name="author" content="watcher"/><meta name="created" content="2023-01-24 14:03:19 +0000"/><meta name="latitude" content="30.24366760253906"/><meta name="longitude" content="103.4184132081826"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2023-01-31 14:46:42 +0000"/><title>Mybatis-[plus] ****</title></head><body><ol><li><div>持久化层框架Mybatis【<span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(247, 49, 49); font-family: Arial, sans-serif; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">专门用来将数据进行持久化的框架,也就是说将数据存储到数据库中的框架</span>】</div></li><li><div>封装的是原来的JDBC【JDBC用来访问数据库，操作数据等功能】</div></li><li><div>持久层框架包括：SQL Maps【java数据与数据库数据的映射关系】</div></li></ol><div>                                         Data Access Objects（DAO）【数据访问对象】</div><ol start="4"><li><div>支持定制化SQL，存储过程以及高级映射</div></li><li><div>Hibernate 和 JPA 基于全映射的全自动框架，开发效率稍高于Mybatis，但可以接受</div></li><li><div>如果单纯的操作库，项目结构之需要 mysql与mybatis 而不需要 springBoot</div></li></ol><div><br/></div><ul><li><div>mybatis获取参数值</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px; font-family: Monaco;"><font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">${}</font>  // 本质是字符串拼接（出现sql注入，单引号需要区分）</span></div><div><span style="font-size: 12px; font-family: Monaco;"><font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">#{}</font>  // 本质是占位符赋值（能用最好，有些必须用上面的，如like 语句用#{}有问题）</span></div><div><font face="Monaco">     // like ‘%${username}%’</font></div><div><font face="Monaco">     // like concat(‘%’, #{username}, ‘%’)  — 字符串拼接函数</font></div><div><font face="Monaco"><span>     // like “%”#{username}”%”  - 最常用的</span><br/></font></div><div><span style="font-size: 12px; font-family: Monaco;"><span>     // in (${ids})  - 不能用#{} 因为#{}会自动加单引号</span><br/></span></div><div><span style="font-size: 12px; font-family: Monaco;"><span>     // 表名不能加单引号  select * from ${tableName}  不能用 #{tableName}</span></span></div><div><font face="Monaco">总结两种：</font></div><div><font face="Monaco">1. 实体类</font></div><div><font face="Monaco">2. @Param(“”)注解</font></div></div><ul><li><div>mybatis查询语句select</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">注意：</font></div><div><font face="Monaco">1. 实体类返回</font></div><div><font face="Monaco">2. list集合返回</font></div><div><font face="Monaco">3. map集合返回</font></div><div><font face="Monaco">4. List&lt;Map&gt;返回 或 @MapKey(“id”)注解 【两种方式返回结构不一样】</font></div></div><ul><li><div>resultMap</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">解决数据库字段名与实体属性名不一致</font></div><div><font face="Monaco">1. 为字段名起别名，保持与属性名一致</font></div><div><font face="Monaco">2. 全局配置mapUnderscoreToCamelCase来解决下划线与驼峰的一致性</font></div><div><font face="Monaco">3. resultMap来配置属性名对应【自定义映射】</font></div><div><font face="Monaco"><br/></font></div><div><span style="font-family: Monaco;">多对一 对应 对象</span></div><div><span style="font-size: 12px; font-family: Monaco;">一对多 对应 集合</span></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">多对一映射关系</font></div><div><font face="Monaco">1. resultMap 级联映射【用的并不多】</font></div><div><font style="font-family: Monaco;">   &lt;resultMap&gt;</font></div><div><font><font style="font-family: Monaco;">        &lt;id property=“id” column=“id"&gt;&lt;/id&gt;</font><br/></font></div><div><font style="font-family: Monaco;"><span>    <span>    &lt;result </span></span></font>property=“name” column=“name"<font style="font-family: Monaco;"><span><span>&gt;&lt;/result&gt;</span></span><br/></font></div><div><font style="font-family: Monaco;"><span>    <span>    </span></span></font>&lt;result property=“dept.deptId” column=“dept_id"&gt;&lt;/result&gt;</div><div><font style="font-family: Monaco;"><span>    <span>    </span></span></font>&lt;result property=“dept.deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div><font style="font-family: Monaco;">   &lt;/</font>resultMap&gt;</div><div>2. resultMap association来解决</div><div>   &lt;resultMap&gt;</div><div>        &lt;id property=“id” column=“id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“name” column=“name"&gt;&lt;/result&gt;</div><div><span>    <span>    &lt;</span></span>association property=“dept” <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">javaType</font>=“Dept”&gt;</div><div>        <span>    </span>&lt;result property=“deptId” column=“dept_id"&gt;&lt;/result&gt;</div><div>        <span>    </span>&lt;result property=“deptName” column=“dept_name"&gt;&lt;/result&gt;<br/></div><div><span>    <span>    </span></span>&lt;/association&gt;</div><div>   &lt;/resultMap&gt;</div><div>3. 分布查询解决多对一【以后用的比较多的方式】</div><div>   先查询主表信息，根据主表再查询子表</div><div><span style="font-size: 12px; font-family: Monaco;">   // association 里面的 column 属性表示 下一个select Sql中查询的条件（分布查询条件）</span></div><div><span style="font-size: 12px; font-family: Monaco;">   // 注意 select的引用 是 mapper层的唯一标识</span></div><div>   &lt;resultMap&gt;</div><div>        &lt;id property=“id” column=“id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“name” column=“name"&gt;&lt;/result&gt;</div><div>        &lt;association property=“dept” select=“com.watcher.mapper.DeptMapper.getDeptById” column=“did”&gt;&lt;/association&gt;</div><div>   &lt;/resultMap&gt;</div><div>   // 第二个sql返回的数据结构由第二个sql的查询resultType决定的</div><div><br/></div><div>   可能在另一个xml中</div><div>   &lt;select id=“getDeptById” resultType=“Dept”&gt;</div><div><span>    <span>    select * … where id=#{did}</span></span><br/></div><div><span>   </span>&lt;/select&gt;</div><div><br/></div><div>分布查询优点</div><div>1. <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">延迟加载 </font></div><div>   （需要全局配置延迟加载</div><div><span>    </span>lazyLoadingEnabled: true // 延迟加载的全局开关</div><div><span>    aggressiveLazyLoading: false // 任何方法的调用都会加载该对象的所有属性，否则每个属性按需加载</span></div><div><span>    // 第一个开启，第二个关闭</span></div><div>    // 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql</div><div>    // 通过配置&lt;association&gt;与&lt;collection&gt;的fetchType属性设置当前的分布查询是否使用延迟加载</div><div>    // fetchType=“lazy/eager” |延迟加载/立即加载）当配置了全局延迟加载时，可以单独里面去掉延迟加载，但不可以单独延迟加载<br/></div><div>// 当前访问的是哪些信息就只执行相应的sql，如拿到用户信息</div><div>// user.getUserName() // 只拿用户则不会执行部门的sql</div><div>// sout(user) // 输出用户肯定包含了用户中的部门则会执行部门sql</div><div><br/></div><div><br/></div><div>一对多映射关系（因为是集合没有级联映射）</div><div>1. resultMap collection解决</div><div>   &lt;resultMap type=“Dept"&gt;</div><div><span>    <span>    </span></span>&lt;id property=“deptId” column=“dept_id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div>        &lt;collection property=“userList” <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">ofType</font>=“User"&gt;</div><div>            &lt;result property=“userId” column=“user_id"&gt;&lt;/result&gt;</div><div>            &lt;result property=“userName” column=“user_name"&gt;&lt;/result&gt;</div><div>        &lt;/collection&gt;<br/></div><div>   &lt;/resultMap&gt;</div><div><br/></div><div>2. 分布查询解决一对多</div><div>   &lt;resultMap&gt;</div><div>        &lt;id property=“deptId” column=“dept_id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div>        &lt;collection property=“userList” select=“com.watcher.mapper.UserMapper.getUserByDeptId” column=“deptId”&gt;&lt;/collection&gt;</div><div>   &lt;/resultMap&gt;</div><div><br/></div><div><span>   </span>可能在另一个xml中</div><div>   &lt;select id=“getUserByDeptId” resultType=“User”&gt;</div><div>        select * … where dept_id=#{deptId}</div><div>   &lt;/select&gt;<br/></div><div><br/></div></div><div><br/></div><ul><li><div>动态SQL</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>