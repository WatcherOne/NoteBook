<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.6.2 (469632)"/><meta name="altitude" content="0"/><meta name="author" content="watcher"/><meta name="created" content="2023-01-24 14:03:19 +0000"/><meta name="latitude" content="30.24366760253906"/><meta name="longitude" content="103.4184132081826"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2023-02-06 14:40:28 +0000"/><title>Mybatis - *****</title></head><body><ol><li><div>持久化层框架Mybatis【<span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(247, 49, 49); font-family: Arial, sans-serif; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">专门用来将数据进行持久化的框架,也就是说将数据存储到数据库中的框架</span>】</div></li><li><div>封装的是原来的JDBC【JDBC用来访问数据库，操作数据等功能】</div></li><li><div>持久层框架包括：SQL Maps【java数据与数据库数据的映射关系】</div></li></ol><div>                                         Data Access Objects（DAO）【数据访问对象】</div><ol start="4"><li><div>支持定制化SQL，存储过程以及高级映射</div></li><li><div>Hibernate 和 JPA 基于全映射的全自动框架，开发效率稍高于Mybatis，但可以接受</div></li><li><div>如果单纯的操作库，项目结构之需要 mysql与mybatis 而不需要 springBoot</div></li></ol><div><br/></div><ul><li><div>mybatis获取参数值</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px; font-family: Monaco;"><font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">${}</font>  // 本质是字符串拼接（出现sql注入，单引号需要区分）</span></div><div><span style="font-size: 12px; font-family: Monaco;"><font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">#{}</font>  // 本质是占位符赋值（能用最好，有些必须用上面的，如like 语句用#{}有问题）</span></div><div><font face="Monaco">     // like ‘%${username}%’</font></div><div><font face="Monaco">     // like concat(‘%’, #{username}, ‘%’)  — 字符串拼接函数</font></div><div><font face="Monaco">     // like “%”#{username}”%”  - 最常用的</font></div><div><span style="font-size: 12px; font-family: Monaco;">     // in (${ids})  - 不能用#{} 因为#{}会自动加单引号</span></div><div><span style="font-size: 12px; font-family: Monaco;">     // 表名不能加单引号  select * from ${tableName}  不能用 #{tableName}</span></div><div><font face="Monaco">总结两种：</font></div><div><font face="Monaco">1. 实体类</font></div><div><font face="Monaco">2. @Param(“”)注解</font></div></div><ul><li><div>mybatis查询语句select</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">注意：</font></div><div><font face="Monaco">1. 实体类返回</font></div><div><font face="Monaco">2. list集合返回</font></div><div><font face="Monaco">3. map集合返回</font></div><div><font face="Monaco">4. List&lt;Map&gt;返回 或 @MapKey(“id”)注解 【两种方式返回结构不一样】</font></div></div><ul><li><div>resultMap</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">解决数据库字段名与实体属性名不一致</font></div><div><font face="Monaco">1. 为字段名起别名，保持与属性名一致</font></div><div><font face="Monaco">2. 全局配置mapUnderscoreToCamelCase来解决下划线与驼峰的一致性</font></div><div><font face="Monaco">3. resultMap来配置属性名对应【自定义映射】</font></div><div><font face="Monaco"><br/></font></div><div><span style="font-family: Monaco;">多对一 对应 对象</span></div><div><span style="font-size: 12px; font-family: Monaco;">一对多 对应 集合</span></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">多对一映射关系</font></div><div><font face="Monaco">1. resultMap 级联映射【用的并不多】</font></div><div><font style="font-family: Monaco;">   &lt;resultMap&gt;</font></div><div><font><font style="font-family: Monaco;">        &lt;id property=“id” column=“id"&gt;&lt;/id&gt;</font></font></div><div><font style="font-family: Monaco;">        &lt;result </font>property=“name” column=“name"<font style="font-family: Monaco;">&gt;&lt;/result&gt;</font></div><div><font style="font-family: Monaco;">        </font>&lt;result property=“dept.deptId” column=“dept_id"&gt;&lt;/result&gt;</div><div><font style="font-family: Monaco;">        </font>&lt;result property=“dept.deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div><font style="font-family: Monaco;">   &lt;/</font>resultMap&gt;</div><div>2. resultMap association来解决</div><div>   &lt;resultMap&gt;</div><div>        &lt;id property=“id” column=“id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“name” column=“name"&gt;&lt;/result&gt;</div><div>        &lt;association property=“dept” <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">javaType</font>=“Dept”&gt;</div><div>            &lt;result property=“deptId” column=“dept_id"&gt;&lt;/result&gt;</div><div>            &lt;result property=“deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div>        &lt;/association&gt;</div><div>   &lt;/resultMap&gt;</div><div>3. 分布查询解决多对一【以后用的比较多的方式】</div><div>   先查询主表信息，根据主表再查询子表</div><div><span style="font-size: 12px; font-family: Monaco;">   // association 里面的 column 属性表示 下一个select Sql中查询的条件（分布查询条件）</span></div><div><span style="font-size: 12px; font-family: Monaco;">   // 注意 select的引用 是 mapper层的唯一标识</span></div><div>   &lt;resultMap&gt;</div><div>        &lt;id property=“id” column=“id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“name” column=“name"&gt;&lt;/result&gt;</div><div>        &lt;association property=“dept” select=“com.watcher.mapper.DeptMapper.getDeptById” column=“did”&gt;&lt;/association&gt;</div><div>   &lt;/resultMap&gt;</div><div>   // 第二个sql返回的数据结构由第二个sql的查询resultType决定的</div><div><br/></div><div>   可能在另一个xml中</div><div>   &lt;select id=“getDeptById” resultType=“Dept”&gt;</div><div>        select * … where id=#{did}</div><div>   &lt;/select&gt;</div><div><br/></div><div>分布查询优点</div><div>1. <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">延迟加载 </font></div><div>   （需要全局配置延迟加载</div><div>    lazyLoadingEnabled: true // 延迟加载的全局开关</div><div>    aggressiveLazyLoading: false // 任何方法的调用都会加载该对象的所有属性，否则每个属性按需加载</div><div>    // 第一个开启，第二个关闭</div><div>    // 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql</div><div>    // 通过配置&lt;association&gt;与&lt;collection&gt;的fetchType属性设置当前的分布查询是否使用延迟加载</div><div>    // fetchType=“lazy/eager” |延迟加载/立即加载）当配置了全局延迟加载时，可以单独里面去掉延迟加载，但不可以单独延迟加载</div><div>// 当前访问的是哪些信息就只执行相应的sql，如拿到用户信息</div><div>// user.getUserName() // 只拿用户则不会执行部门的sql</div><div>// sout(user) // 输出用户肯定包含了用户中的部门则会执行部门sql</div><div><br/></div><div><br/></div><div>一对多映射关系（因为是集合没有级联映射）</div><div>1. resultMap collection解决</div><div>   &lt;resultMap type=“Dept"&gt;</div><div>        &lt;id property=“deptId” column=“dept_id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div>        &lt;collection property=“userList” <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">ofType</font>=“User"&gt;</div><div>            &lt;result property=“userId” column=“user_id"&gt;&lt;/result&gt;</div><div>            &lt;result property=“userName” column=“user_name"&gt;&lt;/result&gt;</div><div>        &lt;/collection&gt;</div><div>   &lt;/resultMap&gt;</div><div><br/></div><div>2. 分布查询解决一对多</div><div>   &lt;resultMap&gt;</div><div>        &lt;id property=“deptId” column=“dept_id"&gt;&lt;/id&gt;</div><div>        &lt;result property=“deptName” column=“dept_name"&gt;&lt;/result&gt;</div><div>        &lt;collection property=“userList” select=“com.watcher.mapper.UserMapper.getUserByDeptId” column=“deptId”&gt;&lt;/collection&gt;</div><div>   &lt;/resultMap&gt;</div><div><br/></div><div>   可能在另一个xml中</div><div>   &lt;select id=“getUserByDeptId” resultType=“User”&gt;</div><div>        select * … where dept_id=#{deptId}</div><div>   &lt;/select&gt;</div><div><br/></div></div><div><br/></div><ul><li><div>动态SQL</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// 根据特定条件动态拼接sql语句的功能</div><div>1. &lt;if test=“”&gt;&lt;/if&gt; test必须的，里面是condition</div><div>2. &lt;where&gt;&lt;/where&gt; // 会将内容前多余 and / or 去掉，没有内容时，不会有 where 关键字</div><div>                   // <font style="color: rgb(255, 78, 21); --inversion-type-color: simple;">不能将内容后</font>多余的 and / or 去掉</div><div>3. &lt;trim prefix=“” suffix=“” prefixOverrides=“” suffixOverrides=“"&gt;&lt;/trim&gt;</div><div>        // prefix/suffix - 将trim标签中内容前面或后面添加指定内容</div><div>        // prefixOverrides - 将trim标签中内容前面去掉指定内容</div><div>        // suffixOverrides - 后面</div><div>        // 没有内容时，prefix/suffix也不起作用</div><div>  &lt;trim prefix=“where” suffixOverrides=“and|or”&gt;</div><div>    &lt;if …&gt;</div><div>       name = #{name} and</div><div>    &lt;/if&gt;</div><div>    &lt;if …&gt;</div><div>       age = #{age} and</div><div>    &lt;/if&gt;</div><div>  &lt;/trim&gt;</div><div>  // 就是创建where语句并删除后面的and或者or</div><div>4. choose…then…otherwise…   === if…else if…else</div><div>   &lt;choose&gt;</div><div>      &lt;when test=“”&gt;&lt;/when&gt;</div><div>      &lt;when test=“”&gt;&lt;/when&gt;</div><div>      &lt;otherwise&gt;&lt;/otherwise&gt;</div><div>   &lt;/choose&gt;</div><div>   // when 至少一个 otherwise 最多只有一个</div><div><br/></div><div>5. &lt;foreach collection=“” item=“” separator=“” open=“” close=“”&gt;&lt;/foreach&gt;  // 对数组或集合进行循环</div><div>        // collection - 当前循环的数组或集合</div><div>        // item - 数组中的每一个元素</div><div>        // separator - 分隔符，每个元素之间的连接符</div><div>        // open/close - 当前循环的内容以什么开始 以什么结束</div><div>   in （</div><div>    &lt;foreach collection=“ids” item=“id”&gt;</div><div>        #{id}</div><div>    &lt;/foreach&gt;</div><div>   )</div><div><font face="Monaco">   // 去掉前后括号，加属性 open=“(“ close=“)”</font></div><div><font face="Monaco">   </font></div><div><font face="Monaco">   用where的方式删除</font></div><div><font face="Monaco">   where</font></div><div><font face="Monaco">   </font>&lt;foreach collection=“ids” item=“id” separator=“or"&gt;</div><div>        id = #{id}</div><div>   &lt;/foreach&gt;</div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div><font face="Monaco">6. &lt;sql id=“"&gt;&lt;/sql&gt;  // id - 当前sql片段的唯一标识</font></div><div><font face="Monaco">   &lt;include refid=“”&gt;&lt;/include&gt;. // redid 关联 id值 就引用了 当前SQL片段</font></div><div><br/></div></div><div><br/></div><ul><li><div>Mybatis的缓存【只针对查询功能有效】</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>一级缓存</div><div>一级缓存是 SqlSession 级别的，通用同一个 SqlSession 查询的数据会被缓存，下次查询相同的数据就会从缓存中直接获取，不会从数据库重新访问</div><div>1.默认开启的</div><div>2.同一个 SqlSession 的查询条件一样才会缓存</div><div>3.不同的 SqlSession对一不同的一级缓存</div><div>4.同一个 SqlSession 两次查询期间执行了任何一次增删改操作不会缓存</div><div><span style="font-size: 12px; font-family: Monaco;">5.手动清空了缓存不会缓存数据</span></div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div><font face="Monaco">二级缓存</font></div><div><font face="Monaco">二级缓存是 SqlSessionFactory 级别的，通过一个 SqlSessionFactory 创建的 SqlSession 查询的结果会被缓存，此后再此执行相同的查询，结果会从缓存中获取</font></div><div><font face="Monaco">开启条件：</font></div><div><font face="Monaco">1. 在核心配置文件中，设置全局配置属性cacheEnabled=“true”，默认是 true，不需要配置</font></div><div><font face="Monaco">2. 在映射文件中设置标签&lt;cache/&gt;</font></div><div><font face="Monaco">3. 二级缓存必须在 SqlSession 关闭或提交之后有效 === 当 SqlSession 没有关闭或提交之前，数据会保存到一级缓存中，当关闭或提交之后会保存到二级缓存中</font></div><div><font face="Monaco">4.查询的数据所转换的实体类类型必须实现序列化的接口</font></div><div>上面4个条件必须满足</div><div><br/></div><div><span>只有当两次查询之间执行了任意的增删改 才会使二级缓存失效</span></div><div><span><br/></span></div><div><span><br/></span></div><div>相关配置</div><div><font face="Monaco">&lt;cache … /&gt;</font></div><div><font face="Monaco">1. eviction: 缓存回收策略</font></div><div><font face="Monaco">A. LRU - 最近最少使用：移除最长时间不被使用的对象，默认</font></div><div><font face="Monaco">B. FIFO - 先进先出：按对象进入缓存的顺序来移除</font></div><div><font face="Monaco">C. SOFT - 软引用 </font></div><div><font face="Monaco">D. WEAK - 弱引用</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">2. </font>flushInterval: 刷新间隔，毫秒</div><div><span style="font-size: 12px; font-family: Monaco;"><span>    默认情况是不设置即没有刷新间隔，缓存仅仅调用语句时刷新</span><br/></span></div><div><span style="font-size: 12px; font-family: Monaco;"><span><span>    语句指增删改语句</span><br/></span></span></div><div><span style="font-size: 12px; font-family: Monaco;"><span><span><br/></span></span></span></div><div><span style="font-size: 12px; font-family: Monaco;"><span>3. size属性：引用数目，正整数</span></span></div><div><span style="font-size: 12px; font-family: Monaco;"><span><span>    代表缓存最多可以缓存多少个对象，太大容易导致内存溢出</span><br/></span></span></div><div><font face="Monaco"><br/></font></div><div><font style="font-family: Monaco;">4. readOnly: 只读 true/false, 默认false</font></div><div><font face="Monaco">   true: 只读缓存，会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，提供了很多性能优势</font></div><div><font style="font-family: Monaco;">   false：读写缓存，会返回<font style="color: rgb(255, 95, 0); --inversion-type-color: simple;">缓存对象的拷贝</font>(通过序列化)，会慢一点，但安全</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">缓存查询顺序</font></div><div><font face="Monaco">1. 先 二级缓存，因为二级缓存中可能有其它程序已经查出来的数据，可以直接拿来用</font></div><div><font face="Monaco">2. 如果二级缓存没有命中，再查询一级缓存</font></div><div><font face="Monaco">3. 如果一级缓存也没有命中，则查询数据库</font></div><div><span style="font-size: 12px; font-family: Monaco;">4. SqlSession关闭之后，一级缓存中的数据会写入二级缓存中</span></div><div><span style="font-size: 12px; font-family: Monaco;"><br/></span></div><div><span style="font-size: 12px; font-family: Monaco;">Mybatis 可以整合第三方缓存 来代替二级缓存，一级缓存不能替换，如第三方缓存：EHCache，只需要会配置即可，了解</span></div></div><div><br/></div><ul><li><div>逆向工程：一个插件用于自动生成Mapper类，Mapper.xml映射文件等</div></li><li><div>Mybatis-plus 可以自动逆向好像？</div></li></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>
