// Todo: 传参 & snippets: generator 案例


/// 如何动态提供？

一种 新的函数控制解决方案，控制函数什么时候执行，什么时候暂停
本质上是一个特殊的迭代器
生成器对象本身也实现了迭代器接口

当我们使用 for...of 遍历生成器对象时，该循环会自动调用生成器的 next 方法，并且在迭代器指示完成之前会持续遍历
利用 for...of 来遍历生成器对象是最佳的方式

生成器: 是指能够动态提供数据的对象, 它允许你定义一个包含自有迭代算法的函数, 同时它可以自动维护自己的状态; 生成器是ES6新增的一个极为灵活的结构, 拥有在一个函数块内暂停和恢复代码执行的能力

生成器是一种返回迭代器的函数？* 不太一样 好像

生成器函数使用 function* 语法编写
调用生成器函数会产生一个生成器对象, 生成器对象一开始处于暂停执行（suspended）的状态
与迭代器相似，生成器对象也实现了Iterator接口，因此具有next（）方法,
next返回值 类似与 迭代器
==> 生成器函数被调用时, 其中的代码并不会被立刻执行
    而是返回一个迭代器 Iterator; 只会在初次调用 next() 方法后开始执行！！
==> 顺序问题: 只有调用 next 方法 才会进入 函数内部进行执行

生成器会在每个 yield 语句后停止执行, 在函数中停止执行的能力是极其强大的
yield 关键字指定了迭代器在被调用next的方法是应当按顺序返回的值
在没有调用 next() 方法的时候，生成器函数里的的代码并不会执行
同时也可用通过 return 返回生成器函数的返回值, 通过 return 直接跳出该生成器
生成器对象有个 throw() 方法可以关闭生成器, 还有 return() 方法

上一次让生成器函数暂停的 yield 关键字会接收到传给 next() 方法的第一个值
yield可以作为输入输出

```
function* generatorFn(initial) {

console.log(initial);

console.log(yield);

console.log(yield);

}
```
```
function* generatorFn() {

return yield 1;

}
```

yield*最有用的地方是实现递归操作
```
function* Fn(n) {

    if (n > 0) {
        // 再看！
        yield* nTimes(n - 1);
        yield n - 1;
    }
}
```

每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数
结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象
从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数






[所谓动态提供数据，大白话就是“要一个，给一个”，而不是直接生成所有数据。因此与字典和集合（空间换时间）相反，生成器是典型的时间换空间的例子]




作用:
1. 遍历/迭代集合(数组)所有元素

